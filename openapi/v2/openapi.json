{
  "swagger": "2.0",
  "info": {
    "title": "Fulfillment API",
    "version": "0.0.1",
    "contact": {
      "name": "Innabox project",
      "url": "https://github.com/innabox"
    },
    "license": {
      "name": "Apache-2.0",
      "url": "https://github.com/innabox/fulfillment-api/blob/main/LICENSE"
    }
  },
  "tags": [
    {
      "name": "ClusterOrders"
    },
    {
      "name": "ClusterTemplates"
    },
    {
      "name": "Clusters"
    },
    {
      "name": "Events"
    }
  ],
  "schemes": [
    "https"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/api/fulfillment/v1/cluster_orders": {
      "get": {
        "summary": "Retrieves the list of cluster orders.",
        "operationId": "ClusterOrders_List",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClusterOrdersListResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "description": "Index of the first result. If not specified the default value will be zero.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "limit",
            "description": "Maximum number of results to be returned by the server. When not specified all the results will be returned. Note\nthat there may not be enough results to return, and that the server may decide, for performance reasons, to return\nless results than requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names\nof the attributes of the order instead of the names of the columns of a table. For example, in order to retrieve\nall the orders with state `FULFILLED` the value should be:\n\n    state = 'FULLFILLED'\n\nIf this isn't provided, or if the value is empty, then all the orders that the user has permission to see will be\nreturned.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "order",
            "description": "Order criteria.\n\nThe syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the\nnames of the attributes of the order instead of the names of the columns of a table. For example, in order to sort\nthe orders descending by state the value should be:\n\n    state desc\n\nIf the parameter isn't provided, or if the value is empty, then the order of the results is undefined.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "ClusterOrders"
        ]
      },
      "post": {
        "summary": "Places a new cluster order.",
        "operationId": "ClusterOrders_Place",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClusterOrdersPlaceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1ClusterOrdersPlaceRequest"
            }
          }
        ],
        "tags": [
          "ClusterOrders"
        ]
      }
    },
    "/api/fulfillment/v1/cluster_orders/{order_id}": {
      "get": {
        "summary": "Retrieves the details of one specific cluster order.",
        "operationId": "ClusterOrders_Get",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClusterOrdersGetResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "order_id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "ClusterOrders"
        ]
      },
      "delete": {
        "summary": "Cancels a cluster order.",
        "operationId": "ClusterOrders_Cancel",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClusterOrdersCancelResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "order_id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "ClusterOrders"
        ]
      }
    },
    "/api/fulfillment/v1/cluster_templates": {
      "get": {
        "summary": "Retrieves the list of cluster templates.",
        "operationId": "ClusterTemplates_List",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClusterTemplatesListResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "description": "Index of the first result. If not specified the default value will be zero.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "limit",
            "description": "Maximum number of results to be returned by the server. When not specified all the results will be returned. Note\nthat there may not be enough results to return, and that the server may decide, for performance reasons, to return\nless results than requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names\nof the attributes of the template instead of the names of the columns of a table. For example, in order to retrieve\nall the templates with a title starting with `large` the value should be:\n\n    title like 'large%'\n\nIf this isn't provided, or if the value is empty, then all the templates that the user has permission to see will\nbe returned.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "order",
            "description": "Order criteria.\n\nThe syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the\nnames of the attributes of the templated instead of the names of the columns of a table. For example, in order to\nsort the templates descending by title the value should be:\n\n    name desc\n\nIf the parameter isn't provided, or if the value is empty, then the order of the results is undefined.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "ClusterTemplates"
        ]
      }
    },
    "/api/fulfillment/v1/cluster_templates/{template_id}": {
      "get": {
        "summary": "Retrieves the details of one specific cluster template.",
        "operationId": "ClusterTemplates_Get",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClusterTemplatesGetResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "template_id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "ClusterTemplates"
        ]
      }
    },
    "/api/fulfillment/v1/clusters": {
      "get": {
        "summary": "Retrieves the list of clusters.",
        "operationId": "Clusters_List",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClustersListResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "description": "Index of the first result. If not specified the default value will be zero.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "limit",
            "description": "Maximum number of results to be returned by the server. When not specified all the results will be returned. Note\nthat there may not be enough results to return, and that the server may decide, for performance reasons, to return\nless results than requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names\nof the attributes of the cluster instead of the names of the columns of a table. For example, in order to retrieve\nall the cluster with a API URL starting with `http:` the value should be:\n\n    api_url like 'http:%'\n\nIf this isn't provided, or if the value is empty, then all the clusters that the user has permission to see will be\nreturned.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "order",
            "description": "Order criteria.\n\nThe syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the\nnames of the attributes of the cluster instead of the names of the columns of a table. For example, in order to\nsort the clusters descending by API URL the value should be:\n\n    api_url desc\n\nIf the parameter isn't provided, or if the value is empty, then the order of the results is undefined.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Clusters"
        ]
      }
    },
    "/api/fulfillment/v1/clusters/{cluster_id}": {
      "get": {
        "summary": "Retrieves the details of one specific cluster.",
        "operationId": "Clusters_Get",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClustersGetResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Clusters"
        ]
      }
    },
    "/api/fulfillment/v1/clusters/{cluster_id}/kubeconfig": {
      "get": {
        "summary": "Returns the admin Kubeconfig of the cluster.",
        "description": "This is intended for use with HTTP and returns the YAML text of the Kubeconfig directly using the content type\n`application/yaml`.\n\nbuf:lint:ignore RPC_RESPONSE_STANDARD_NAME",
        "operationId": "Clusters_GetKubeconfigViaHttp",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiHttpBody"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Clusters"
        ]
      }
    },
    "/api/fulfillment/v1/events": {
      "get": {
        "summary": "Watches events.",
        "operationId": "Events_Watch",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/definitions/v1EventsWatchResponse"
                },
                "error": {
                  "$ref": "#/definitions/rpcStatus"
                }
              },
              "title": "Stream result of v1EventsWatchResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "from",
            "description": "When this parameter is used the server will only send the events that are newer than the event with this\nidentifier. Note that the event with this identifier will *not* be sent.\n\nWhen this parameter isn't used the server will send only the events that are generated after the request is\nreceived.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names\nof the attributes of the event instead of the names of the columns of a table. For example, in order to get only\nthe events of type `CREATED` the value should be:\n\n    type = 'CREATED'\n\nIf this isn't provided, or if the value is empty, then all the events that the user has permission to see will be\nreturned.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Events"
        ]
      }
    }
  },
  "definitions": {
    "apiHttpBody": {
      "type": "object",
      "properties": {
        "content_type": {
          "type": "string",
          "description": "The HTTP Content-Type header value specifying the content type of the body."
        },
        "data": {
          "type": "string",
          "format": "byte",
          "description": "The HTTP request/response body as raw binary."
        },
        "extensions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          },
          "description": "Application specific response metadata. Must be set in the first response\nfor streaming APIs."
        }
      },
      "description": "Message that represents an arbitrary HTTP body. It should only be used for\npayload formats that can't be represented as JSON, such as raw binary or\nan HTML page.\n\n\nThis message can be used both in streaming and non-streaming API methods in\nthe request as well as the response.\n\nIt can be used as a top-level request field, which is convenient if one\nwants to extract parameters from either the URL or HTTP template into the\nrequest fields and also want access to the raw HTTP body.\n\nExample:\n\n    message GetResourceRequest {\n      // A unique request id.\n      string request_id = 1;\n\n      // The raw HTTP body is bound to this field.\n      google.api.HttpBody http_body = 2;\n\n    }\n\n    service ResourceService {\n      rpc GetResource(GetResourceRequest)\n        returns (google.api.HttpBody);\n      rpc UpdateResource(google.api.HttpBody)\n        returns (google.protobuf.Empty);\n\n    }\n\nExample with streaming methods:\n\n    service CaldavService {\n      rpc GetCalendar(stream google.api.HttpBody)\n        returns (stream google.api.HttpBody);\n      rpc UpdateCalendar(stream google.api.HttpBody)\n        returns (stream google.api.HttpBody);\n\n    }\n\nUse of this type only changes how the request and response bodies are\nhandled, all other features will continue to work unchanged."
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        }
      },
      "additionalProperties": {},
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := \u0026pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "v1Cluster": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the cluster."
        },
        "spec": {
          "$ref": "#/definitions/v1ClusterSpec"
        },
        "status": {
          "$ref": "#/definitions/v1ClusterStatus"
        }
      },
      "description": "A cluster contains the details of the cluster. The spec contains the desired details, and man be modified by the\nuser.The status contains the current status of the cluster, is provided by the system and can't be modified by the\nuser."
    },
    "v1ClusterOrder": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the order. This will be automatically generated by the system when the order is placed."
        },
        "spec": {
          "$ref": "#/definitions/v1ClusterOrderSpec"
        },
        "status": {
          "$ref": "#/definitions/v1ClusterOrderStatus"
        }
      },
      "description": "A cluster order contains the details that the user provides to request the provisioning of a cluster, as well as the\ncurrent status of the order provided by the system."
    },
    "v1ClusterOrderSpec": {
      "type": "object",
      "properties": {
        "template_id": {
          "type": "string",
          "description": "Reference to the cluster template. This is mandatory, and must be the value of the `id` field of one of the cluster\ntemplates."
        }
      },
      "description": "The spec contains the details that the user provides to request the provisioning of the cluster."
    },
    "v1ClusterOrderState": {
      "type": "string",
      "enum": [
        "CLUSTER_ORDER_STATE_UNSPECIFIED",
        "CLUSTER_ORDER_STATE_ACCEPTED",
        "CLUSTER_ORDER_STATE_REJECTED",
        "CLUSTER_ORDER_STATE_CANCELED",
        "CLUSTER_ORDER_STATE_FULFILLED",
        "CLUSTER_ORDER_STATE_FAILED"
      ],
      "default": "CLUSTER_ORDER_STATE_UNSPECIFIED",
      "description": "The cluster state indicates the overall state of the processing of the order.\n\n - CLUSTER_ORDER_STATE_UNSPECIFIED: Unspecified indicates that the value isn't set.\n - CLUSTER_ORDER_STATE_ACCEPTED: Accepted indicates that the order has been accepted by the system.\n - CLUSTER_ORDER_STATE_REJECTED: Rejected indicates that the order has been rejected by the system.\n - CLUSTER_ORDER_STATE_CANCELED: Canceled indicates that the order has been canceled by the user.\n - CLUSTER_ORDER_STATE_FULFILLED: Fulfilled indicates that the order has been successfully fulfilled.\n - CLUSTER_ORDER_STATE_FAILED: Failed indicates that fulfillment of the order failed."
    },
    "v1ClusterOrderStatus": {
      "type": "object",
      "properties": {
        "state": {
          "$ref": "#/definitions/v1ClusterOrderState",
          "description": "State indicates the current state of the processing of the order."
        },
        "cluster_id": {
          "type": "string",
          "description": "Reference to the resulting cluster. This will be automatically populated by the system when the requested cluster\nis completely provisoned. Further details about the cluster, like the API URL, will be available in the\ncorresponding `Cluster` object."
        }
      },
      "description": "The status contains the current status of the order."
    },
    "v1ClusterOrdersCancelResponse": {
      "type": "object"
    },
    "v1ClusterOrdersGetResponse": {
      "type": "object",
      "properties": {
        "order": {
          "$ref": "#/definitions/v1ClusterOrder"
        }
      }
    },
    "v1ClusterOrdersListResponse": {
      "type": "object",
      "properties": {
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Actual number of items returned. Note that this may be smaller than the value requested in the `limit` parameter\nof the request if there are not enough items, or of the system decides that returning that number of items isn't\nfeasible or convenient for performance reasons."
        },
        "total": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of items of the collection that match the search criteria, regardless of the number of results\nrequested with the `limit` parameter."
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ClusterOrder"
          },
          "description": "List of results."
        }
      }
    },
    "v1ClusterOrdersPlaceRequest": {
      "type": "object",
      "properties": {
        "order": {
          "$ref": "#/definitions/v1ClusterOrder"
        }
      }
    },
    "v1ClusterOrdersPlaceResponse": {
      "type": "object",
      "properties": {
        "order": {
          "$ref": "#/definitions/v1ClusterOrder"
        }
      }
    },
    "v1ClusterSpec": {
      "type": "object",
      "description": "The spec contains the details of a cluster as desired by the user. Note that currently this is empty because all the\ndetails of the cluster are provided by the system."
    },
    "v1ClusterStatus": {
      "type": "object",
      "properties": {
        "api_url": {
          "type": "string",
          "description": "URL of te API server of the cluster."
        },
        "console_url": {
          "type": "string",
          "description": "URL of the console of the cluster."
        }
      },
      "description": "The status contains the details of the cluster provided by the system."
    },
    "v1ClusterTemplate": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the template."
        },
        "title": {
          "type": "string",
          "description": "Human friendly short description of the template, only a few words, suitable for displaying in one single\nline on a UI or CLI."
        },
        "description": {
          "type": "string",
          "description": "Human friendly long description of the template, using Markdown format."
        }
      },
      "description": "A cluster template defines a type of cluster that can be ordered by the user. Note that the user doesn't create these\ntemplates: the system provides a collection of them, and the user chooses one."
    },
    "v1ClusterTemplatesGetResponse": {
      "type": "object",
      "properties": {
        "template": {
          "$ref": "#/definitions/v1ClusterTemplate"
        }
      }
    },
    "v1ClusterTemplatesListResponse": {
      "type": "object",
      "properties": {
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Actual number of items returned. Note that this may be smaller than the value requested in the `limit` parameter\nof the request if there are not enough items, or of the system decides that returning that number of items isn't\nfeasible or convenient for performance reasons."
        },
        "total": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of items of the collection that match the search criteria, regardless of the number of results\nrequested with the `limit` parameter."
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ClusterTemplate"
          },
          "description": "List of results."
        }
      }
    },
    "v1ClustersGetKubeconfigResponse": {
      "type": "object",
      "properties": {
        "kubeconfig": {
          "type": "string"
        }
      }
    },
    "v1ClustersGetResponse": {
      "type": "object",
      "properties": {
        "cluster": {
          "$ref": "#/definitions/v1Cluster"
        }
      }
    },
    "v1ClustersListResponse": {
      "type": "object",
      "properties": {
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Actual number of items returned. Note that this may be smaller than the value requested in the `limit` parameter\nof the request if there are not enough items, or of the system decides that returning that number of items isn't\nfeasible or convenient for performance reasons."
        },
        "total": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of items of the collection that match the search criteria, regardless of the number of results\nrequested with the `limit` parameter."
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Cluster"
          },
          "description": "List of results."
        }
      }
    },
    "v1Event": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the event. This will be automatically generated by the system when the event is generated.\n\nThe only guarantee about the values of these identifiers is that they are unique. Note in particular that there\nis no guarantee of order: clients should refrain from assuming that they are ordered in any way."
        },
        "type": {
          "$ref": "#/definitions/v1EventType",
          "description": "Type of event."
        },
        "old": {
          "$ref": "#/definitions/protobufAny",
          "description": "Old contains the representation of the object before update or delete. It will be empty for other types of events."
        },
        "new": {
          "$ref": "#/definitions/protobufAny",
          "description": "New contains the representation of the object after creation or update. It will be empty for other types of events."
        }
      },
      "description": "Events are generated by the system when objects are created, updated or deleted."
    },
    "v1EventType": {
      "type": "string",
      "enum": [
        "EVENT_TYPE_UNSPECIFIED",
        "EVENT_TYPE_CREATE",
        "EVENT_TYPE_UPDATE",
        "EVENT_TYPE_DELETE"
      ],
      "default": "EVENT_TYPE_UNSPECIFIED",
      "description": " - EVENT_TYPE_UNSPECIFIED: Unspecified indicates that the type of event hasn't been specified.\n - EVENT_TYPE_CREATE: Create indicates that a new object has been created. The `new` field will contain the represenation of that\nobject. The `old` field will be empty.\n - EVENT_TYPE_UPDATE: Update indicates that an existing object has been updated. The `old` and `new` fields will contain the\nrepresentations of the object before and after the update.\n - EVENT_TYPE_DELETE: Delete indicates that an object has been deleted. The `old` field will contain the representation of the object\nright before it was deleted. The `new` field will be empty."
    },
    "v1EventsWatchResponse": {
      "type": "object",
      "properties": {
        "event": {
          "$ref": "#/definitions/v1Event"
        }
      }
    }
  }
}
