{
  "swagger": "2.0",
  "info": {
    "title": "Fulfillment API",
    "version": "0.0.1",
    "contact": {
      "name": "Innabox project",
      "url": "https://github.com/innabox"
    },
    "license": {
      "name": "Apache-2.0",
      "url": "https://github.com/innabox/fulfillment-api/blob/main/LICENSE"
    }
  },
  "tags": [
    {
      "name": "ClusterOrders"
    },
    {
      "name": "ClusterTemplates"
    },
    {
      "name": "Clusters"
    }
  ],
  "schemes": [
    "https"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/api/fulfillment/v1/cluster_orders": {
      "get": {
        "summary": "Retrieves the list of cluster orders.",
        "operationId": "ClusterOrders_List",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClusterOrdersListResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "description": "Index of the first result. If not specified the default value will be zero.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "limit",
            "description": "Maximum number of results to be returned by the server. When not specified all the results will be returned. Note\nthat there may not be enough results to return, and that the server may decide, for performance reasons, to return\nless results than requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names\nof the attributes of the order instead of the names of the columns of a table. For example, in order to retrieve\nall the orders with state `FULFILLED` the value should be:\n\n    state = 'FULLFILLED'\n\nIf this isn't provided, or if the value is empty, then all the orders that the user has permission to see will be\nreturned.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "order",
            "description": "Order criteria.\n\nThe syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the\nnames of the attributes of the order instead of the names of the columns of a table. For example, in order to sort\nthe orders descending by state the value should be:\n\n    state desc\n\nIf the parameter isn't provided, or if the value is empty, then the order of the results is undefined.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "ClusterOrders"
        ]
      },
      "post": {
        "summary": "Places a new cluster order.",
        "operationId": "ClusterOrders_Place",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClusterOrdersPlaceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1ClusterOrdersPlaceRequest"
            }
          }
        ],
        "tags": [
          "ClusterOrders"
        ]
      }
    },
    "/api/fulfillment/v1/cluster_orders/{order_id}": {
      "get": {
        "summary": "Retrieves the details of one specific cluster order.",
        "operationId": "ClusterOrders_Get",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClusterOrdersGetResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "order_id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "ClusterOrders"
        ]
      },
      "delete": {
        "summary": "Cancels a cluster order.",
        "operationId": "ClusterOrders_Cancel",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClusterOrdersCancelResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "order_id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "ClusterOrders"
        ]
      }
    },
    "/api/fulfillment/v1/cluster_templates": {
      "get": {
        "summary": "Retrieves the list of cluster templates.",
        "operationId": "ClusterTemplates_List",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClusterTemplatesListResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "description": "Index of the first result. If not specified the default value will be zero.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "limit",
            "description": "Maximum number of results to be returned by the server. When not specified all the results will be returned. Note\nthat there may not be enough results to return, and that the server may decide, for performance reasons, to return\nless results than requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names\nof the attributes of the template instead of the names of the columns of a table. For example, in order to retrieve\nall the templates with a title starting with `large` the value should be:\n\n    title like 'large%'\n\nIf this isn't provided, or if the value is empty, then all the templates that the user has permission to see will\nbe returned.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "order",
            "description": "Order criteria.\n\nThe syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the\nnames of the attributes of the templated instead of the names of the columns of a table. For example, in order to\nsort the templates descending by title the value should be:\n\n    name desc\n\nIf the parameter isn't provided, or if the value is empty, then the order of the results is undefined.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "ClusterTemplates"
        ]
      }
    },
    "/api/fulfillment/v1/cluster_templates/{template_id}": {
      "get": {
        "summary": "Retrieves the details of one specific cluster template.",
        "operationId": "ClusterTemplates_Get",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClusterTemplatesGetResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "template_id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "ClusterTemplates"
        ]
      }
    },
    "/api/fulfillment/v1/clusters": {
      "get": {
        "summary": "Retrieves the list of clusters.",
        "operationId": "Clusters_List",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClustersListResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "description": "Index of the first result. If not specified the default value will be zero.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "limit",
            "description": "Maximum number of results to be returned by the server. When not specified all the results will be returned. Note\nthat there may not be enough results to return, and that the server may decide, for performance reasons, to return\nless results than requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names\nof the attributes of the cluster instead of the names of the columns of a table. For example, in order to retrieve\nall the cluster with a API URL starting with `http:` the value should be:\n\n    api_url like 'http:%'\n\nIf this isn't provided, or if the value is empty, then all the clusters that the user has permission to see will be\nreturned.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "order",
            "description": "Order criteria.\n\nThe syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the\nnames of the attributes of the cluster instead of the names of the columns of a table. For example, in order to\nsort the clusters descending by API URL the value should be:\n\n    api_url desc\n\nIf the parameter isn't provided, or if the value is empty, then the order of the results is undefined.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Clusters"
        ]
      }
    },
    "/api/fulfillment/v1/clusters/{cluster_id}": {
      "get": {
        "summary": "Retrieves the details of one specific cluster.",
        "operationId": "Clusters_Get",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClustersGetResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Clusters"
        ]
      }
    },
    "/api/fulfillment/v1/clusters/{cluster_id}/kubeconfig": {
      "get": {
        "summary": "Returns the admin Kubeconfig of the cluster.",
        "description": "This is intended for use with HTTP and returns the YAML text of the Kubeconfig directly using the content type\n`application/yaml`.\n\nbuf:lint:ignore RPC_RESPONSE_STANDARD_NAME",
        "operationId": "Clusters_GetKubeconfigViaHttp",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiHttpBody"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Clusters"
        ]
      }
    }
  },
  "definitions": {
    "apiHttpBody": {
      "type": "object",
      "properties": {
        "content_type": {
          "type": "string",
          "description": "The HTTP Content-Type header value specifying the content type of the body."
        },
        "data": {
          "type": "string",
          "format": "byte",
          "description": "The HTTP request/response body as raw binary."
        },
        "extensions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          },
          "description": "Application specific response metadata. Must be set in the first response\nfor streaming APIs."
        }
      },
      "description": "Message that represents an arbitrary HTTP body. It should only be used for\npayload formats that can't be represented as JSON, such as raw binary or\nan HTML page.\n\n\nThis message can be used both in streaming and non-streaming API methods in\nthe request as well as the response.\n\nIt can be used as a top-level request field, which is convenient if one\nwants to extract parameters from either the URL or HTTP template into the\nrequest fields and also want access to the raw HTTP body.\n\nExample:\n\n    message GetResourceRequest {\n      // A unique request id.\n      string request_id = 1;\n\n      // The raw HTTP body is bound to this field.\n      google.api.HttpBody http_body = 2;\n\n    }\n\n    service ResourceService {\n      rpc GetResource(GetResourceRequest)\n        returns (google.api.HttpBody);\n      rpc UpdateResource(google.api.HttpBody)\n        returns (google.protobuf.Empty);\n\n    }\n\nExample with streaming methods:\n\n    service CaldavService {\n      rpc GetCalendar(stream google.api.HttpBody)\n        returns (stream google.api.HttpBody);\n      rpc UpdateCalendar(stream google.api.HttpBody)\n        returns (stream google.api.HttpBody);\n\n    }\n\nUse of this type only changes how the request and response bodies are\nhandled, all other features will continue to work unchanged."
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        }
      },
      "additionalProperties": {},
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := \u0026pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "v1Cluster": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the cluster."
        },
        "spec": {
          "$ref": "#/definitions/v1ClusterSpec"
        },
        "status": {
          "$ref": "#/definitions/v1ClusterStatus"
        }
      },
      "description": "Contains the details of the cluster.\n\nThe `spec` contains the desired details, and may be modified by the user. The `status` contains the current status of\nthe cluster, is provided by the system and can't be modified by the user."
    },
    "v1ClusterCondition": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/v1ClusterConditionType",
          "description": "Indicates the type of condition."
        },
        "status": {
          "type": "boolean",
          "description": "Indicates the status of the condition."
        },
        "last_transition_time": {
          "type": "string",
          "format": "date-time",
          "description": "This time is the last time that the condition was updated."
        },
        "reason": {
          "type": "string",
          "description": "Contains a the reason of the condition in a format suitable for use by programs.\n\nThe possible values will be documented in the object that contains the condition."
        },
        "message": {
          "type": "string",
          "description": "Contains a text giving more details of the condition.\n\nThis will usually be progress reports, or error messages, and are intended for use by humans, to debug problems."
        }
      },
      "description": "Contains the details of a condition that describes the status of a cluster."
    },
    "v1ClusterConditionType": {
      "type": "string",
      "enum": [
        "CLUSTER_CONDITION_TYPE_UNSPECIFIED",
        "CLUSTER_CONDITION_TYPE_PROGRESSING",
        "CLUSTER_CONDITION_TYPE_READY",
        "CLUSTER_CONDITION_TYPE_FAILED"
      ],
      "default": "CLUSTER_CONDITION_TYPE_UNSPECIFIED",
      "description": "Types of conditions used to describe the status of cluster.\n\n - CLUSTER_CONDITION_TYPE_UNSPECIFIED: Unspecified indicates that the condition is unknown.\n\nThis will never be appear in the `spec.conditions` field of a cluster.\n - CLUSTER_CONDITION_TYPE_PROGRESSING: Indicates that the cluster isn't completely ready yet.\n\nCurrently there are no `reason` values defined.\n - CLUSTER_CONDITION_TYPE_READY: Indicates that the cluster is ready to use.\n\nCurrently there are no `reason` values defined.\n - CLUSTER_CONDITION_TYPE_FAILED: Indicates that the cluster is unusable.\n\nCurrently there are no `reason` values defined."
    },
    "v1ClusterOrder": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the order.\n\nThis will be automatically generated by the system when the order is placed."
        },
        "spec": {
          "$ref": "#/definitions/v1ClusterOrderSpec"
        },
        "status": {
          "$ref": "#/definitions/v1ClusterOrderStatus"
        }
      },
      "description": "Contains the details that the user provides to request the provisioning of a cluster, as well as the current status\nof the order provided by the system."
    },
    "v1ClusterOrderCondition": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/v1ClusterOrderConditionType",
          "description": "Indicates the type of condition."
        },
        "status": {
          "$ref": "#/definitions/v1ConditionStatus",
          "description": "Indicates status of the condition."
        },
        "last_transition_time": {
          "type": "string",
          "format": "date-time",
          "description": "This time is the last time that the condition was updated."
        },
        "reason": {
          "type": "string",
          "description": "Contains a the reason of the condition in a format suitable for use by programs.\n\nThe possible are documented in the `ClusterOrderConditionType` object."
        },
        "message": {
          "type": "string",
          "description": "Contains a text giving more details of the condition. This will usually be progress reports, or error messages, and\nare intended for use by humans, to debug problems."
        }
      },
      "description": "Contains the details of a condition that describes the status of a cluster order."
    },
    "v1ClusterOrderConditionType": {
      "type": "string",
      "enum": [
        "CLUSTER_ORDER_CONDITION_TYPE_UNSPECIFIED",
        "CLUSTER_ORDER_CONDITION_TYPE_ACCEPTED",
        "CLUSTER_ORDER_CONDITION_TYPE_REJECTED",
        "CLUSTER_ORDER_CONDITION_TYPE_CANCELED",
        "CLUSTER_ORDER_CONDITION_TYPE_FULFILLED",
        "CLUSTER_ORDER_CONDITION_TYPE_FAILED"
      ],
      "default": "CLUSTER_ORDER_CONDITION_TYPE_UNSPECIFIED",
      "description": "Types of conditions used to describe a cluster order.\n\n - CLUSTER_ORDER_CONDITION_TYPE_UNSPECIFIED: Unspecified indicates that the condition unknown.\n\nThis will never be appear in the `spec.conditions` field of a order.\n - CLUSTER_ORDER_CONDITION_TYPE_ACCEPTED: Accepted indicates that the order has been accepted by the system.\n - CLUSTER_ORDER_CONDITION_TYPE_REJECTED: Rejected indicates that the order has been rejected by the system, so no further processing will be fulfill it.\n - CLUSTER_ORDER_CONDITION_TYPE_CANCELED: Canceled indicates that the order has been canceled by the user.\n - CLUSTER_ORDER_CONDITION_TYPE_FULFILLED: Fulfilled indicates that the order has been successfully fulfilled.\n\nThe details of the resulting cluster will be available in the `cluster` object indicated by the `status.cluster_id`\nfield.\n - CLUSTER_ORDER_CONDITION_TYPE_FAILED: Failed indicates that fulfillment of the order failed.\n\nCurrently there are no sepcific `reason` values defined."
    },
    "v1ClusterOrderSpec": {
      "type": "object",
      "properties": {
        "template_id": {
          "type": "string",
          "description": "Reference to the cluster template.\n\nThis is mandatory, and must be the value of the `id` field of one of the cluster templates."
        }
      },
      "description": "Contains the details that the user provides to request the provisioning of the cluster."
    },
    "v1ClusterOrderState": {
      "type": "string",
      "enum": [
        "CLUSTER_ORDER_STATE_UNSPECIFIED",
        "CLUSTER_ORDER_STATE_PROGRESSING",
        "CLUSTER_ORDER_STATE_FULFILLED",
        "CLUSTER_ORDER_STATE_FAILED"
      ],
      "default": "CLUSTER_ORDER_STATE_UNSPECIFIED",
      "description": "Represents the overall state of the order.\n\n - CLUSTER_ORDER_STATE_UNSPECIFIED: Unspecified indicates that the state is unknown.\n - CLUSTER_ORDER_STATE_PROGRESSING: Indicates that the order isn't completelly fulfilled yet.\n - CLUSTER_ORDER_STATE_FULFILLED: Indicates indicates that the order has been successfully fulfilled.\n\nThe details of the resulting cluster will be available in the `cluster` object indicated by the `status.cluster_id`\nfield.\n - CLUSTER_ORDER_STATE_FAILED: Indicates that fulfillment of the order failed."
    },
    "v1ClusterOrderStatus": {
      "type": "object",
      "properties": {
        "state": {
          "$ref": "#/definitions/v1ClusterOrderState",
          "description": "Indicates the overall state of the order.\n\nFor more details check the conditions."
        },
        "conditions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ClusterOrderCondition"
          },
          "description": "Contains a list of conditions that describe in detail the status of the order.\n\nFor example, an order that failed could be represented like this (when converted to JSON):\n\n   {\n     \"id\": \"123\",\n     \"spec\": {\n       \"template_id\": \"245\"\n     },\n     \"state\": \"CLUSTER_ORDER_STATE_FAILED\",\n     \"status\": {\n       \"conditions\": [\n         {\n           \"type: \"CLUSTER_ORDER_CONDITION_TYPE_ACCEPTED\",\n           \"status\": \"CONDITION_STATUS_TRUE\",\n           \"last_transition_time\": \"2025-03-12 20:15:59+00:00\",\n           \"message\": \"The order has been automatically approved\"\n         },\n         {\n           \"type\": \"CLUSTER_ORDER_CONDITION_TYPE_FULFILLED\",\n           \"status\": \"CONDITION_STATUS_FALSE\",\n           \"last_transition_time\": \"2025-03-12 20:17:16+00:00\"\n         },\n         {\n           \"type\": \"CLUSTER_ORDER_CONDITION_TYPE_FAILED\",\n           \"status\": \"CONDITION_STATUS_TRUE\",\n           \"last_transition_time\": \"2025-03-12 20:18:59+00:00\",\n           \"reason\": \"DnsProvisioningFailure\",\n           \"message\": \"Failed to create DNS domain 'example.com' because it already exists\"\n         }\n       ]\n     }\n   }\n\nIn this example the `ACCEPTED` condition is true. That tells us that the order was accepted, and the details tell\nus that it was automatically approved.\n\nThe `FUFILLED` condition isn't false. That means that order isn't fulfilled, without any other detail.\n\nThe `FAILED` condition is true, so it is telling us that the fulfillment failed. It also gives additional detail\nin the with both a _reason_ intended for use by programs, and some some details to help humans understand and debug\nthe issue.\n\nNote that in this example, to make it shorter, only three conditions appear. In general all the conditions (except\n`UNPSECIFIED`) will appear exactly once.\n\nNote also that this is just an example, in particular the `DnsProvisioningFailure` reason for the failed condition\nis imaginary. Check the documentation of the values of the `ClusterOrderConditionType` enumerated type to see\npossible values for the reason."
        },
        "cluster_id": {
          "type": "string",
          "description": "Reference to the resulting cluster.\n\nThis will be automatically populated by the system when the requested cluster is completely provisoned. Further\ndetails about the cluster, like the API URL, will be available in the corresponding `Cluster` object."
        }
      },
      "description": "Contains the current status of the order."
    },
    "v1ClusterOrdersCancelResponse": {
      "type": "object"
    },
    "v1ClusterOrdersGetResponse": {
      "type": "object",
      "properties": {
        "order": {
          "$ref": "#/definitions/v1ClusterOrder"
        }
      }
    },
    "v1ClusterOrdersListResponse": {
      "type": "object",
      "properties": {
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Actual number of items returned. Note that this may be smaller than the value requested in the `limit` parameter\nof the request if there are not enough items, or of the system decides that returning that number of items isn't\nfeasible or convenient for performance reasons."
        },
        "total": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of items of the collection that match the search criteria, regardless of the number of results\nrequested with the `limit` parameter."
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ClusterOrder"
          },
          "description": "List of results."
        }
      }
    },
    "v1ClusterOrdersPlaceRequest": {
      "type": "object",
      "properties": {
        "order": {
          "$ref": "#/definitions/v1ClusterOrder"
        }
      }
    },
    "v1ClusterOrdersPlaceResponse": {
      "type": "object",
      "properties": {
        "order": {
          "$ref": "#/definitions/v1ClusterOrder"
        }
      }
    },
    "v1ClusterSpec": {
      "type": "object",
      "description": "The spec contains the details of a cluster as desired by the user.\n\nNote that currently this is empty because there are no properties of the cluster that can be modified by the user."
    },
    "v1ClusterState": {
      "type": "string",
      "enum": [
        "CLUSTER_STATE_UNSPECIFIED",
        "CLUSTER_STATE_PROGRESSING",
        "CLUSTER_STATE_READY",
        "CLUSTER_STATE_FAILED"
      ],
      "default": "CLUSTER_STATE_UNSPECIFIED",
      "description": "Represents the overall state of a cluster.\n\n - CLUSTER_STATE_UNSPECIFIED: Unspecified indicates that the state is unknown.\n - CLUSTER_STATE_PROGRESSING: Indicates that the cluster isn't ready yet.\n - CLUSTER_STATE_READY: Indicates indicates that the cluster is ready.\n - CLUSTER_STATE_FAILED: Indicates indicates that the cluster is unusable."
    },
    "v1ClusterStatus": {
      "type": "object",
      "properties": {
        "state": {
          "$ref": "#/definitions/v1ClusterState",
          "description": "Indicates the overall state of the cluster."
        },
        "conditions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ClusterCondition"
          },
          "description": "Contains a list of conditions that describe in detail the status of the cluster.\n\nFor example, an cluster that is ready could be represented like this (when converted to JSON):\n\n   {\n     \"id\": \"123\",\n     \"spec\": {\n     },\n     \"status\": {\n       \"state\": \"CLUSTER_STATE_READY\",\n       \"conditions\": [\n         {\n           \"type\": \"CLUSTER_CONDITION_TYPE_READY\",\n           \"status\": \"CONDITION_STATUS_TRUE\",\n           \"last_transition_time\": \"2025-03-12 20:15:59+00:00\",\n           \"message\": \"The cluster is ready to use\",\n         },\n         {\n           \"type\": \"CLUSTER_CONDITION_TYPE_FAILED\",\n           \"status\": \"CONDITION_STATUS_FALSE\",\n           \"last_transition_time\": \"2025-03-12 20:10:59+00:00\"\n         }\n       ]\n     }\n   }\n\nIn this example the `READY` condition is true. That tells us that the cluster is ready to use via the API URL\nprovided in the `status.api_url` field.\n\nThe `FAILED` condition is false. That tells us that the cluster is *not* failed.\n\nNote that in this example, to make it shorter, only one condition appears. In general all the conditions (except\n`UNSPECIFIED`) will appear exactly once.\n\nCheck the documentation of the values of the `ClusterConditionType` enumerated type to see possible conditions and\nreasons."
        },
        "api_url": {
          "type": "string",
          "description": "URL of te API server of the cluster.\n\nThis will be empty if the cluster isn't ready."
        },
        "console_url": {
          "type": "string",
          "description": "URL of the console of the cluster.\n\nThis will be empty if the cluster isn't ready or the console isn't enabled."
        }
      },
      "description": "The status contains the details of the cluster provided by the system."
    },
    "v1ClusterTemplate": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the template."
        },
        "title": {
          "type": "string",
          "description": "Human friendly short description of the template, only a few words, suitable for displaying in one single\nline on a UI or CLI."
        },
        "description": {
          "type": "string",
          "description": "Human friendly long description of the template, using Markdown format."
        }
      },
      "description": "A cluster template defines a type of cluster that can be ordered by the user. Note that the user doesn't create these\ntemplates: the system provides a collection of them, and the user chooses one."
    },
    "v1ClusterTemplatesGetResponse": {
      "type": "object",
      "properties": {
        "template": {
          "$ref": "#/definitions/v1ClusterTemplate"
        }
      }
    },
    "v1ClusterTemplatesListResponse": {
      "type": "object",
      "properties": {
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Actual number of items returned. Note that this may be smaller than the value requested in the `limit` parameter\nof the request if there are not enough items, or of the system decides that returning that number of items isn't\nfeasible or convenient for performance reasons."
        },
        "total": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of items of the collection that match the search criteria, regardless of the number of results\nrequested with the `limit` parameter."
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ClusterTemplate"
          },
          "description": "List of results."
        }
      }
    },
    "v1ClustersGetKubeconfigResponse": {
      "type": "object",
      "properties": {
        "kubeconfig": {
          "type": "string"
        }
      }
    },
    "v1ClustersGetResponse": {
      "type": "object",
      "properties": {
        "cluster": {
          "$ref": "#/definitions/v1Cluster"
        }
      }
    },
    "v1ClustersListResponse": {
      "type": "object",
      "properties": {
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Actual number of items returned. Note that this may be smaller than the value requested in the `limit` parameter\nof the request if there are not enough items, or of the system decides that returning that number of items isn't\nfeasible or convenient for performance reasons."
        },
        "total": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of items of the collection that match the search criteria, regardless of the number of results\nrequested with the `limit` parameter."
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Cluster"
          },
          "description": "List of results."
        }
      }
    },
    "v1ConditionStatus": {
      "type": "string",
      "enum": [
        "CONDITION_STATUS_UNSPECIFIED",
        "CONDITION_STATUS_TRUE",
        "CONDITION_STATUS_FALSE"
      ],
      "default": "CONDITION_STATUS_UNSPECIFIED",
      "description": " - CONDITION_STATUS_UNSPECIFIED: Indicates that the system can't decide if the object is in the condition or not.\n - CONDITION_STATUS_TRUE: Indicates that the object is in the condition.\n - CONDITION_STATUS_FALSE: Indicates that the object is not in the condition."
    }
  }
}
